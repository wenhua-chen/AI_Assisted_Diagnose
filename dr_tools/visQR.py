from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals
import sys
sys.path.append('/home/steven/mask_rcnn_caffe2/Detectron-xRay/lib/utils/')
import cv2
import numpy as np
import os
import re
import pycocotools.mask as mask_util

# from utils.colormap import colormap
# import utils.env as envu
# import utils.keypoints as keypoint_utils

# envu.set_up_matplotlib()
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon

plt.rcParams['pdf.fonttype'] = 42  # For editing in Adobe Illustrator

_GRAY = (218, 227, 218)
_GREEN = (18, 127, 15)
_WHITE = (255, 255, 255)


import numpy as np


def colormap(rgb=False):
    color_list = np.array(
        [
            0.000, 0.447, 0.741,
            0.850, 0.325, 0.098,
            0.929, 0.694, 0.125,
            0.494, 0.184, 0.556,
            0.466, 0.674, 0.188,
            0.301, 0.745, 0.933,
            0.635, 0.078, 0.184,
            0.300, 0.300, 0.300,
            0.600, 0.600, 0.600,
            1.000, 0.000, 0.000,
            1.000, 0.500, 0.000,
            0.749, 0.749, 0.000,
            0.000, 1.000, 0.000,
            0.000, 0.000, 1.000,
            0.667, 0.000, 1.000,
            0.333, 0.333, 0.000,
            0.333, 0.667, 0.000,
            0.333, 1.000, 0.000,
            0.667, 0.333, 0.000,
            0.667, 0.667, 0.000,
            0.667, 1.000, 0.000,
            1.000, 0.333, 0.000,
            1.000, 0.667, 0.000,
            1.000, 1.000, 0.000,
            0.000, 0.333, 0.500,
            0.000, 0.667, 0.500,
            0.000, 1.000, 0.500,
            0.333, 0.000, 0.500,
            0.333, 0.333, 0.500,
            0.333, 0.667, 0.500,
            0.333, 1.000, 0.500,
            0.667, 0.000, 0.500,
            0.667, 0.333, 0.500,
            0.667, 0.667, 0.500,
            0.667, 1.000, 0.500,
            1.000, 0.000, 0.500,
            1.000, 0.333, 0.500,
            1.000, 0.667, 0.500,
            1.000, 1.000, 0.500,
            0.000, 0.333, 1.000,
            0.000, 0.667, 1.000,
            0.000, 1.000, 1.000,
            0.333, 0.000, 1.000,
            0.333, 0.333, 1.000,
            0.333, 0.667, 1.000,
            0.333, 1.000, 1.000,
            0.667, 0.000, 1.000,
            0.667, 0.333, 1.000,
            0.667, 0.667, 1.000,
            0.667, 1.000, 1.000,
            1.000, 0.000, 1.000,
            1.000, 0.333, 1.000,
            1.000, 0.667, 1.000,
            0.167, 0.000, 0.000,
            0.333, 0.000, 0.000,
            0.500, 0.000, 0.000,
            0.667, 0.000, 0.000,
            0.833, 0.000, 0.000,
            1.000, 0.000, 0.000,
            0.000, 0.167, 0.000,
            0.000, 0.333, 0.000,
            0.000, 0.500, 0.000,
            0.000, 0.667, 0.000,
            0.000, 0.833, 0.000,
            0.000, 1.000, 0.000,
            0.000, 0.000, 0.167,
            0.000, 0.000, 0.333,
            0.000, 0.000, 0.500,
            0.000, 0.000, 0.667,
            0.000, 0.000, 0.833,
            0.000, 0.000, 1.000,
            0.000, 0.000, 0.000,
            0.143, 0.143, 0.143,
            0.286, 0.286, 0.286,
            0.429, 0.429, 0.429,
            0.571, 0.571, 0.571,
            0.714, 0.714, 0.714,
            0.857, 0.857, 0.857,
            1.000, 1.000, 1.000
        ]
    ).astype(np.float32)
    color_list = color_list.reshape((-1, 3)) * 255
    if not rgb:
        color_list = color_list[:, ::-1]
    return color_list


def convert_from_cls_format(cls_boxes, cls_segms, cls_keyps):
    """Convert from the class boxes/segms/keyps format generated by the testing
    code.
    """
    box_list = [b for b in cls_boxes if len(b) > 0]
    if len(box_list) > 0:
        boxes = np.concatenate(box_list)
    else:
        boxes = None
    if cls_segms is not None:
        segms = [s for slist in cls_segms for s in slist]
    else:
        segms = None
    if cls_keyps is not None:
        keyps = [k for klist in cls_keyps for k in klist]
    else:
        keyps = None
    classes = []
    for j in range(len(cls_boxes)):
        classes += [j] * len(cls_boxes[j])
    return boxes, segms, keyps, classes


def get_class_string(class_index, score, dataset):
    class_text = dataset[class_index] if dataset is not None else \
        'id{:d}'.format(class_index)
    return class_text + ' {:0.2f}'.format(score).lstrip('0')


def vis_one_image(
        im, im_name, output_dir, boxes, segms=None, keypoints=None, thresh=0.9,
        kp_thresh=2, dpi=200, box_alpha=0.0, dataset=None, show_class=False,
        show_box=False,fill_mask=False,random_color=False,show_seges=True,
        ext='',generate_mask=False,mask_dir = None,ignore_cls=['123']):
    """Visual debugging of detections."""
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    if isinstance(boxes, list):
        boxes, segms, keypoints, classes = convert_from_cls_format(
            boxes, segms, keypoints)

    if boxes is None or boxes.shape[0] == 0 or max(boxes[:, 4]) < thresh:
        return


    if segms is not None and len(segms) > 0:
        masks = mask_util.decode(segms)

    fig = plt.figure(frameon=False)
    fig.set_size_inches(im.shape[1] / dpi, im.shape[0] / dpi)
    ax = plt.Axes(fig, [0., 0., 1., 1.])
    ax.axis('off')
    fig.add_axes(ax)
    ax.imshow(im)

    # Display in largest to smallest order to reduce occlusion
    areas = (boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])
    sorted_inds = np.argsort(-areas)

    mask_color_id = 0

    color_lists = [
          (0, 0, 0),
          (1, 0, 0.2),
          (0.3, 0.3, 1),
          (0, 0.3, 0.9),
          (0.9, 0.5, 0.3),
          (0.9, 0.3, 1),
          (0.8, 0.4, 0.3),
          (0.6, 0.9, 0.2),
          (0.6, 0.2, 0.9),
          (0.8, 0.3, 0),
          (0.3, 0.8, 0.7),
          (0.9, 0.9, 1),
          (1, 0.8, 0.4),
          (0.5, 0.1, 0.9),
          (1, 0.5, 1),
          (0.5, 0.8, 1),
          ]

    color_list = colormap(rgb=True) / 255
    # if not random_color:
    #     color_lists = [
    #           (0, 0, 0),
    #           (1, 0, 0.2),
    #           (0.3, 0.3, 1),
    #           (0, 0.3, 0.9),
    #           (0.9, 0.5, 0.3),
    #           (0.9, 0.3, 1),
    #           (0.8, 0.4, 0.3),
    #           (0.6, 0.9, 0.2),
    #           (0.6, 0.2, 0.9),
    #           (0.8, 0.3, 0),
    #           (0.3, 0.8, 0.7),
    #           (0.9, 0.9, 1),
    #           (1, 0.8, 0.4),
    #           (0.5, 0.1, 0.9),
    #           (1, 0.5, 1),
    #           (0.5, 0.8, 1),
    #           ]
    # else:
    #     print('usig_random_color')
    #     color_lists = colormap(rgb=True) / 255

    fei_idx = 0
    mask_dict = {}
    for i in sorted_inds:
        bbox = boxes[i, :4]
        score = boxes[i, -1]
        cls = classes[i]
        try:
            class_text = dataset.classes[cls]
        except:
            class_text = dataset[cls]
        # print(cls)
        if not random_color:
            cls_color = color_lists[cls]
        else:
            cls_color = color_lists[i]

        if score < thresh:
            continue

        if show_box:
            if class_text not in ignore_cls:
                ax.add_patch(
                    plt.Rectangle((bbox[0], bbox[1]),
                                  bbox[2] - bbox[0],
                                  bbox[3] - bbox[1],
                                  fill=False, edgecolor=cls_color,
                                  linewidth=4, alpha=box_alpha))

        if show_class:
            if class_text not in ignore_cls:
                ax.text(
                    bbox[2]+8, bbox[1] + 80,
                    get_class_string(classes[i], score, dataset),
                    fontsize=18,
                    family='serif',
                    bbox=dict(
                        facecolor=cls_color, alpha=0.4, pad=5, edgecolor='none'),
                    color='white')
        # show mask
        if segms is not None and len(segms) > i:
            img = np.ones(im.shape)
            # color_mask = np.random.randint(0, 256, (1, 3), dtype=np.uint8)
            color_mask = color_list[mask_color_id % len(color_list), 0:3]
            mask_color_id += 1

            w_ratio = .4
            for c in range(3):
                color_mask[c] = color_mask[c] * (1 - w_ratio) + w_ratio
            for c in range(3):
                img[:, :, c] = color_mask[c]
            e = masks[:, :, i]


            if generate_mask:
                e[e!=0]=255
                file_name =os.path.basename(im_name)
                filename, file_extension = os.path.splitext(file_name)

                # print('class_text',class_text)
                if class_text == 'fei':
                    # print('fei_idx',fei_idx)
                    output_name = filename+'_'+class_text+str(fei_idx)+'.jpg'
                    mask_dict[class_text+str(fei_idx)]=mask_dir+output_name
                    fei_idx+=1
                else:
                    output_name = filename+'_'+class_text+'.jpg'
                    mask_dict[class_text]=mask_dir+output_name
                if class_text not in ['__background__','qiguan']:
                # if class_text not in ['__background__','qiguan','jizhu','xinying']:
                    mask_path = mask_dir+output_name
                    cv2.imwrite(mask_path,e)
                    # print(mask_path)
            contour, hier = cv2.findContours(
                e.copy(), cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)

            for c in contour:
                if fill_mask:
                    polygon = Polygon(
                        c.reshape((-1, 2)),
                        fill=True, facecolor=color_mask,
                        edgecolor='w', linewidth=1.2,
                        alpha=0.5)
                if show_seges:
                    if class_text not in ignore_cls:
                        polygon = Polygon(
                            c.reshape((-1, 2)),
                            fill=False, facecolor='none',
                            edgecolor=cls_color, linewidth=3,
                            alpha=0.7)
                        ax.add_patch(polygon)

    # output_name = os.path.basename(im_name) + '.' + ext
    output_name = os.path.basename(im_name)
    fig.savefig(os.path.join(output_dir, '{}'.format(output_name)), dpi=dpi)
    plt.close('all')

    return mask_dict
